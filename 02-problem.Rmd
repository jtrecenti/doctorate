# Problema

O problema do Captcha pode ser entendido como um problema de classificação de imagens. Especificamente, nosso interesse é criar uma função $g$ que recebe uma imagem $\mathbf X = \{x_{nmr} \in [0,1]\}_{N\times M \times R}$ e retorna um vetor de índices $\mathbf y$, sendo que cada índice $y_j$ corresponde a um caractere $c_j$, $j = 1, \dots, L$, onde $L$ é o número de caracteres contidos na imagem. Chamaremos $L$ de *comprimento* do Captcha.

Podemos detalhar as afirmações anteriores em três itens, listados abaixo.

1. Nossa variável **explicativa**, a imagem, é uma matriz $\mathbf X = \{x_{ijk}\}_{N\times M \times R}$, em que $N$ é o número de linhas, $M$ é o número de colunas e $R$ é o número de *cores*, ou *canais*. 

O elemento $x_{nm\cdot}$ é denominado *pixel*. Um pixel representa a menor unidade possível da imagem. Em uma imagem colorida, por exemplo, temos $R=3$. Nesse caso, um pixel é um vetor de três dimensões com valores entre zero e um, representando a intensidade de vermelho, verde e azul da coordenada $n,m$ da imagem. Numa imagem em escala de cinza, temos $R=1$ e o pixel, de uma dimensão, representa a intensidade do cinza (com 1=branco e 0=preto).

2. O objeto $C \in \mathcal A^L$ é um vetor de itens de um alfabeto $\mathcal A$ com tamanho $|\mathcal A|$, finito e conhecido. Esse alfabeto contém todos os possíveis caracteres que podem aparecer na imagem.

3. Nossa **resposta** $\mathbf y \in \mathbb \{1, \dots, |\mathcal A|\}^L$ é um vetor de índices de tamanho fixo. Cada elemento de $\mathbf y$ representa um valor do alfabeto $\mathcal A$.

A construção de uma função $g$ capaz de mapear $\mathbf y$ a partir de uma nova imagem $\mathbf X$ depende de uma amostra de imagens $\mathbf X_1, \dots, \mathbf X_S$ corretamente classificadas por $\mathbf y_1, \dots, \mathbf y_S$. A tarefa é, portanto, obter uma estimativa $\hat g$ para a função $g$ que minimiza

$$
L(\hat g(\mathbf X), \mathbf y) = \mathbb I(g(\mathbf X) \neq \mathbf y)
$$

em que $\mathbb I$ é a função indicadora.

## Variantes

### Áudio

Captchas também ser encontrados na forma de áudio. Nesses casos, o usuário é condicionado a ouvir um áudio e transcrever seu conteúdo em um texto.

Com base nos Captchas analisados durante o desenvolvimento do trabalho, verificamos que Captchas de áudio são menos complexos. Por exemplo, alguns destes são formados por sons sem ruído. Ou seja, uma tabela de sons e classificações seria suficiente para quebrar os Captchas.

Nos casos com ruído, podemos utilizar duas técnicas para quebrar Captchas de áudio. A primeira é baseada em engenharia de características [ref], que extrai covariáveis dos áudios, para serem utilizadas posteriormente em um modelo de regressão clássico. O segundo método consiste em calcular o espectrograma do áudio e tratá-lo como um Captcha de imagem.

### Covariáveis e número de respostas variável

Outra forma comum de manifestação de Captchas são imagens em que o número de letras varia. Esse problema é mais complexo que o anterior pois a variável resposta não é mais um vetor de tamanho $L$ fixo.

Assumindo que o número de letras máximo que aparece numa imagem é fixo, uma solução para o problema de tamanho variável é considerar um caractere adicional `_` no alfabeto, chamado *placeholder*, que representa a ausência do caractere em determinada posição. Assim, uma imagem com $L_{\max} = 5$, por exemplo, poderia ter uma classificação `cad5_`, que tem apenas quatro letras.

O problema dessa proposta é que a posição dos *placeholders* não importa na classificação do captcha. Ou seja, as soluções `cad5_`, `ca_d5` e `_cad5` são  equivalentes. Isso aumenta a dificuldade na estimação dos parâmetros por gerar mais ótimos locais.

Outra alternativa para o problema é considerar que um de nossos interesses de predição é justamente o número de letras. Assim, teríamos 

$$
\tilde{\mathbf{y}} = \left[l \;\; \mathbf y^\top \right]^\top,
$$

onde $l$ é o número de letras do Captcha específico e $\mathbf y$ tem comprimento $L_{\max}$, preenchido com *placeholders* como anteriormente. A presença do número de letras como componente da variável resposta do problema permite trabalhar adequadamente com os *placeholders*, pois podemos descartá-los na função de perda (verossimilhança) nos casos em que o número de letras estimadas for menor que $L_{\max}$.

Usualmente, o problema de Captchas de tamanho variável é acompanhado pelo problema das covariáveis. Um tipo comum de Captcha com covariáveis são questões como "digite todas as letras da cor verde". Nesse caso, "verde" é uma covariável, pois é uma das informações que deve ser utilizada em conjunto com a imagem completa para predizr o texto do Captcha.

Inicialmente, pode parecer contra intuitivo considerar uma imagem e um texto como covariáveis para predizer o valor de $\mathbf y$, mas isso se dá de forma natural, principalmente na solução que proposta no Capítulo \@ref(results).

### reCaptcha 2.0

O reCaptcha 2.0 desenvolvido pela Google é o *benchmark* no que se refere a geração de CAPTCHAs. Nesse desafio, o usuário é colocado para resolver diversos tipos de problemas de imagens como reconhecimento de placas de trânsito, fachadas de prédios e carros. O reCaptcha é utilizado não só para barrar robôs, como também para alimentar os modelos estatísticos da própria Google para seus produtos, como, por exemplo, os carros autônomos.

A dificuldade em resolver esses desafios consiste na pluralidade de contextos, não na dificuldade dos desafios [@goodfellow2013multi]. A tarefa de identificar placas de trânsito em imagens é complicada, mas pode ser resolvida com alta taxa de acurácia utilizando-se modelos adequados. No entanto, o reCaptcha pode facilmente mudar a tarefa para identificação de fachadas, ou então identificação de felinos. Do ponto de vista estatístico, cada uma dessas tarefas exige uma base de dados diferente. 

Na prática, o reCaptcha cria um jogo em que o autor do CAPTCHA tem muitas vantagens. O tempo necessário para criar uma nova tarefa é menor que o tempo necessário para resolvê-lo. Até hoje não existe uma solução geral para o reCaptcha 2.0 com taxas satisfatórias de acurácia.

A principal forma de resolver o reCaptcha 2.0 é através da exploração de falhas no sistema de intificação de robôs ou a possibilidade de receber tarefas por áudio [sivakorn2016m]. Outras abordagens utilizam modelos robustos como o ImageNet para identificação genérica de objetos nas imagens, mas sem taxas de sucesso expressivas [mach2017automaticky].



